;; ==================================
;;  CMPU-382, Spring 2020
;;  Sample STNU code
;;  Feb. 6, 2020
;; ==================================

;;  Scheme doesn't have built-in 2-dimensional arrays,
;;  so we build them out of vectors.

;;  MAKE-ARRAY:  Make a 2-d array with R rows and C columns

(define make-array
  (lambda (r c)
    (let ((harry (make-vector r)))
      (dotimes (i r)
               (vector-set! harry i (make-vector c #f)))
      harry)))

;;  ARRAY-REF:  Fetch (r,c) element from 2-d array HARRY

(define array-ref
  (lambda (harry r c)
    (vector-ref (vector-ref harry r) c)))

;;  ARRAY-SET!:  Set (r,c) element of 2-d array HARRY to VAL

(define array-set!
  (lambda (harry r c val)
    (vector-set! (vector-ref harry r) c val)))

;;  STN struct

(define-struct stn
  (tps       ;; vector whose ith element is NAME of ith tp
   edges     ;; 2-d array whose (i,j) element contains length of edge from TPi to TPj (or #f)
   num-succs ;; vector whose ith entry contains the number of successors of each tp
   succs     ;; array whose ith row contains the indices of the successors of ith tp
   ))

;;  CREATE-STN:  creates and initializes an STN using the *vector* of TPS
;;   and inserting edges specified in *list* of constraints

(define create-stn
  (lambda (tps constraints)
    (let* ((num-tps (vector-length tps))
           (s (make-stn tps (make-array num-tps num-tps)
                        (make-vector num-tps 0)
                        (make-array num-tps num-tps))))
      (dolist (constr constraints)
              (insert-edge s (first constr) (second constr) (third constr)))
      s)))

;;  PRINT-STN:  prints out info in given STN

(define print-stn
  (lambda (s)
    (printf "STN:    TPs:   ~A~%        EDGES: ~A~%" (stn-tps s) (stn-edges s))
    (printf "        NUM-SUCCS: ~A~%        SUCCS: ~A~%" (stn-num-succs s) (stn-succs s))
    ))

;;  INDEX-OF:  Returns index of vector VECKY where ITEM occurs (or #f if ITEM doesn't occur in VECKY)

(define index-of
  (lambda (vecky item)
    (let ((indy 0)
          (len (vector-length vecky)))
      (while (and (< indy len)
                  (not (eq? (vector-ref vecky indy) item)))
             (set! indy (1+ indy)))
      (if (< indy len)
          indy
          #f))))

;;  INSERT-EDGE:  Inserts edge from X to Y of length DELTA in stn S

(define insert-edge
  (lambda (s x delta y)
    (let* ((tp-veck (stn-tps s))
           (indy-x (index-of tp-veck x))
           (indy-y (index-of tp-veck y))
           (pre-edge (array-ref (stn-edges s) indy-x indy-y))
           (num-sux (stn-num-succs s))
           (sux (stn-succs s))
           )
      (when (or (not pre-edge)
                (< delta pre-edge))
        ;; set entry in EDGES matrix
        (array-set! (stn-edges s) indy-x indy-y delta))
      (when (not pre-edge)
        ;; inserting new edge, so update NUM-SUCCS vector and SUCCS matrix
        (array-set! (stn-succs s) indy-x (vector-ref num-sux indy-x) indy-y)
        (vector-set! num-sux indy-x (1+ (vector-ref num-sux indy-x)))
        ))))

;; BELLMAN-FORD algorithm on stn S

(define bellman-ford
  (lambda (s)
    ;; s = stn
    ;; src = new source node, don't really need it to be explicit.
    ;; dist = vector whose ith entry contains current distance from src to ith tp in stn
    (let* ((num-tps (vector-length (stn-tps s)))
           ;; note:  initially all distances from s to tps is 0
           (dist (make-vector num-tps 0))
           (num-sux (stn-num-succs s))
           (sux (stn-succs s))
           (edgies (stn-edges s))
           )
      ;; First n-1 rounds
      (dotimes (k (- num-tps 1))
               ;; For each EDGE...
               ;;   Equivalent to:  For each TP, For each SUCC
               (dotimes (i num-tps)
                        (let ((num-sux-of-i (vector-ref num-sux i))
                              (sux-of-i (vector-ref sux i)))
                          (dotimes (j num-sux-of-i)
                                   (let* ((jth-succ-of-i (vector-ref sux-of-i j))
                                          (delta-i-j (array-ref edgies i jth-succ-of-i)))
                                     (when (< (+ (vector-ref dist i) delta-i-j)
                                              (vector-ref dist jth-succ-of-i))
                                       ;; update dist[j]
                                       (vector-set! dist jth-succ-of-i (+ (vector-ref dist i) delta-i-j)))))))
               )
      ;; Last round (if there is an update, then there must be a neg cycle)
      (printf "Umm... Need to do last round...~%")
      dist)))

(define s (create-stn #(a b c d e) '((a -50 d) (a 80 e) (b -10 a) (c 40 e))))
(print-stn s)
(printf "Running bellman-ford: ~A~%" (bellman-ford s))
